/**
 * Ключове слово this
 */

/**
 * Функція це частковий випадок обєкта -тип посилання
 *
 */

console.log('[]===[]', [] === []); //коли ми порівнюємо два масива- різні комірки памяті і вони не рівні
console.log('{}==={}', {} === {}); // незалежні обєкти, різні комірки памяті і вони не рівні

console.log('function(){}===function(){}', function () {} === function () {}); // коли ми порівнюємо дві функції вони також не рівні

/**
 * ! функція це обєкт, це тип посилання, складний тип, і коли ми порівнюємо дві однакові функції то вони не рівні
 * !одна функція лежить в одній комірці памяті а інша в іншій
 * Функція це обєкт і вона передається по посиланню
 */

const fnA = function () {
  // у змінній А також ставить вказівник де зберігається ця функція
  console.log('hello');
};

// const fnB = fnA; // так як функція це складний у змінну B ставиться посилання на комірку памяті в якій збурігається ця функція

// console.log('fnA===fnB:', fnA === fnB); // саме тому ми в такому порівняні отримуємо true

/**
 * два обєкта дорівнюють один одному тільки тоді коли стоїть посилання на один і тот же обєкт
 *
 */

/**
 * як нам дізнатись про контекст цієї функції
 *  - Ключове слово this
 *  - де і як була обявлена функція НЕ МАЄ НІЯКОГО ВПЛИВУ на контекст
 *  - Контекст визначається В МОМЕНТ ВИКЛИКУ ФУНКЦІЇ, якщо він не привязаний явно
 */

// самий простий варіант це коли функція як метод обєкта. В контексті обєкта

// const user = {
//   tag: 'Mango',
//   showTag() {
//     // метод обєкта
//     console.log('showTag-> this', this);
//   },
// };

// user.showTag(); // значення this присвоюється у момент виклику. Тут виклик в контексті обєкта
// якщо зліва віж функції метода стоїть обєкт який її викликає то this в цій функції буде рівнятись цьому обєкту, буде посилання на цей обєкт
// саме тому в метода обєкту ми використовуємо ключове слово this

/**
 * Виклик без контекста
 *  - в строгому режимі = undefined
 *  - не в строгому = window
 */

// const foo = function () {
//   console.log('foo->this', this);
// };

// foo();

/**
 * Як метод обєкта но обявлена як зовнішня функція
 * В контексті обєкта
 */

// const showTag = function () {
//   console.log('showTag -> this', this);
//   console.log('showTag ->this.tag', this.tag);
// };

// showTag();

// const user = {
//   tag: 'Mango',
// };

// user.showUserTag = showTag;
// console.log('user', user);

// user.showUserTag(); //не важливо де ти обявив цю функцію, важливо як ти її викликав

// тому значення this визначається в момент виклику а не в момент обявлення
/**
 * Що выбулося по кроках
 * 1. на властивості user я створив властивість showUserTag і записав туди посилання showTag на оригінальну функцію
 * 2. Після чого ми викликали цей метод user.showUserTag(); в цьому методі лежть посилання на showTag і ця функція викликалась у контексті user
 * Коли вона так викликається її this присвоюється обєкту який її викликав
 *
 */

/**
 * Виклик без контекса, но оголошена як метод обэкта
 */

// const user = {
//   tag: 'Mango',
//   showTag() {
//     console.log('showTag -> this', this);
//     console.log('showTag ->this.tag', this.tag);
//   },
// };

// user.showTag();

// const outerShowTag = user.showTag;

// outerShowTag();

/**
 * Контекст в callback - функції
 */

const user = {
  tag: 'Mango',
  showTag() {
    console.log('showTag->this', this);
    console.log('showTag->this.tag', this.tag);
  },
};

const invokeAction = function (action) {
  console.log(action);
  action();
};

invokeAction(user.showTag);

//27
